\hypertarget{Imports}{%
\subsubsection{\texorpdfstring{Imports\protect\hyperlink{Imports}{¶}}{Imports¶}}\label{Imports}}

In~{[}~{]}:

\begin{verbatim}
import json
import math
import matplotlib.pyplot as plt
import numpy as np
from sklearn import datasets

from qiskit import ClassicalRegister, QuantumCircuit, QuantumRegister
from qiskit.circuit.library import PauliFeatureMap, ZFeatureMap, ZZFeatureMap

from qiskit.opflow import X, Y, Z, I, CircuitStateFn
from qiskit.opflow.state_fns import StateFn
from qiskit.opflow.expectations import PauliExpectation, MatrixExpectation
from qiskit.opflow.converters import CircuitSampler
from qiskit.providers.aer import QasmSimulator
\end{verbatim}

\hypertarget{Definizione-dei-dati}{%
\subsubsection{\texorpdfstring{Definizione dei
dati\protect\hyperlink{Definizione-dei-dati}{¶}}{Definizione dei dati¶}}\label{Definizione-dei-dati}}

Dati sintetici per testare l'esecuzione del codice

In~{[}~{]}:

\begin{verbatim}
DATA = np.array([[0.8, 0.8, 0.8, 0.8], [1, 1, 1, 1]])
FEATURES = DATA.shape[1]
SIZE = DATA.shape[0]
\end{verbatim}

\hypertarget{Circuito-enconding}{%
\subsubsection{\texorpdfstring{Circuito
enconding\protect\hyperlink{Circuito-enconding}{¶}}{Circuito enconding¶}}\label{Circuito-enconding}}

Viene utilizzata una ZZFeatureMap

In~{[}~{]}:

\begin{verbatim}
encode_map = ZZFeatureMap(feature_dimension=FEATURES, reps=1, entanglement='linear', insert_barriers=True)
encode_circuit = encode_map.bind_parameters(DATA[1])
encode_circuit.decompose().draw(output='mpl')
\end{verbatim}

Out{[}~{]}:

\hypertarget{EM-Distance}{%
\subsection{\texorpdfstring{EM
Distance\protect\hyperlink{EM-Distance}{¶}}{EM Distance¶}}\label{EM-Distance}}

Dati due stati \$\textbar\textbackslash psi\textgreater\$ e
\$\textbar\textbackslash phi\textgreater\$, si definisce la distanza EM
approssimata come:

\$ \textbackslash widetilde\{D\}\_\{EM\} = max\_\{H\_i\}\textbar{}
\textless\textbackslash phi\textbar H\textbar{}
\textbackslash phi\textgreater{} -
\textless\textbackslash psi\textbar H\textbar{}
\textbackslash psi\textgreater\textbar{} :
\textbar\textbar H\textbar\textbar\_L \textbackslash leq 1 \$

dato \$O\_n\$ insieme degli observbles su n qbit, si definisce \$H\$

\$ H \textbackslash in O\_n : \textbar\textbar H\textbar\textbar\_L = 2
max\_\{i = 1,\textbackslash dots,n\}
(min\textbackslash\{\{\textbar\textbar H- H\_i
\textbar\textbar\_\{\textbackslash inf\} : H\_i \textbackslash in O\_n
\textbackslash text\{ identità sull'iesimo qbit\}\}\textbackslash\}) \$

Il valore \$\textless\textbackslash phi\textbar H\textbar{}
\textbackslash phi\textgreater\$ equivale al calcolo dell'expectation
dell'osservable H rispetto allo stato
\$\textbar\textbackslash phi\textgreater\$

\hypertarget{Esecuzione-passo-passo}{%
\subsubsection{\texorpdfstring{Esecuzione passo
passo\protect\hyperlink{Esecuzione-passo-passo}{¶}}{Esecuzione passo passo¶}}\label{Esecuzione-passo-passo}}

generate\_pauli(n): Genera le combinazioni di operatori pauli (X,Y,Z)
sui singoli qbit per generare un subset di obsevables con constante di
lipshitz minore o uguale a 1

Nello specifico, gli observables presi in considerazione sono:

\begin{itemize}
\tightlist
\item
  Pauli Z per ogni qbit
\item
  Per ogni qbit k:

  \begin{itemize}
  \tightlist
  \item
    Per ogni qbit j \textless{} k applico Pauli X
  \item
    Per il qbit k applico Pauli X se PARI e Pauli Y se DISPARI
  \item
    Per ogni qbit k \textless{} j applico Pauli Z
  \end{itemize}
\end{itemize}

Vegono considerate quindi n+1 osservabili. Ad esempio, per n=4 qbit
verrano generati i gate: ZZZZ, YZZZ, XXZZ, XXYZ, XXXX

In~{[}~{]}:

\begin{verbatim}
def even(x):
    return (x % 2) == 0


def generate_pauli(n):
    hamiltonians = []

    h = 1
    for _ in range(n):
        h = h^Z
    hamiltonians.append(h)

    for k in range(n):
       
        h = 1

        if(k != 0):
            for _ in range(k):
                h = h^X

        if even(k+1):
            h = h^X
        else:
            h = h^Y

        if (k+1 != n):
            for _ in range(k+1, n):
                h = h^Z


        hamiltonians.append(h)

    return hamiltonians
\end{verbatim}

Compongo il circuito per i due vettori da confrontare.

Dati due vettori x,y viene applicata una ZZFeature map per l'encoding
rispettivamente nei stati \$\textbar\textbackslash psi\textgreater\$ e
\$\textbar\textbackslash phi\textgreater\$.

Viene successivamente composto il circuito che calcola:
\$\textless\textbackslash phi\textbar H\textbar{}
\textbackslash phi\textgreater\$ e
\$\textless\textbackslash psi\textbar H\textbar{}
\textbackslash psi\textgreater\$

con H matrice generata dalla funzione generate\_pauli

In~{[}~{]}:

\begin{verbatim}
x = CircuitStateFn(encode_map.bind_parameters(DATA[0]))
y = CircuitStateFn(encode_map.bind_parameters(DATA[1]))
n = x.num_qubits

observables = generate_pauli(n)

circuit = x.adjoint().compose(observables[4]).compose(x)

print(circuit)
\end{verbatim}

\begin{verbatim}
ComposedOp([
  CircuitMeasurement(
       ┌────────────────────────────────┐┌──────────────┐»
  q_0: ┤0                               ├┤0             ├»
       │                                ││              │»
  q_1: ┤1                               ├┤1             ├»
       │  ZZFeatureMap(0.8,0.8,0.8,0.8) ││  Pauli(XXXX) │»
  q_2: ┤2                               ├┤2             ├»
       │                                ││              │»
  q_3: ┤3                               ├┤3             ├»
       └────────────────────────────────┘└──────────────┘»
  «     ┌───────────────────────────────────┐
  «q_0: ┤0                                  ├
  «     │                                   │
  «q_1: ┤1                                  ├
  «     │  ZZFeatureMap_dg(0.8,0.8,0.8,0.8) │
  «q_2: ┤2                                  ├
  «     │                                   │
  «q_3: ┤3                                  ├
  «     └───────────────────────────────────┘
  ),
  DictStateFn({'0000': 1})
])
\end{verbatim}

Calcolo dell'expected value, questo viene calcolato per ogni obsevable e
per entrambi i vettori, viene calcolata quindi la differenza in valore
assoluto e presa la maggiore, seguendo la definizione di distanza EM

In~{[}~{]}:

\begin{verbatim}
max = 0

for h in observables:

    print(f"Obeservable [{h}]")
    circuit_x = x.adjoint().compose(h).compose(x)
    circuit_y = y.adjoint().compose(h).compose(y)

    EM = abs(circuit_x.eval().real - circuit_y.eval().real)

    print(f'''EM Distance
       |E(x) - E(y)| = {abs(circuit_x.eval().real - circuit_y.eval().real)}''')
        
    print('\n')

print(f"Final EM: {max}")
\end{verbatim}

\begin{verbatim}
Obeservable [ZZZZ]
EM Distance
       |E(x) - E(y)| = 0.0


Obeservable [YZZZ]
EM Distance
       |E(x) - E(y)| = 0.0


Obeservable [XXZZ]
EM Distance
       |E(x) - E(y)| = 0.0


Obeservable [XXYZ]
EM Distance
       |E(x) - E(y)| = 0.01799009887524796


Obeservable [XXXX]
EM Distance
       |E(x) - E(y)| = 0.02998995839471978


Final EM: 0
\end{verbatim}

\hypertarget{EM-Distance-function}{%
\subsubsection{\texorpdfstring{EM Distance
function\protect\hyperlink{EM-Distance-function}{¶}}{EM Distance function¶}}\label{EM-Distance-function}}

Calcolo della distanza con data enconding usando una ZZFeature map

In~{[}~{]}:

\begin{verbatim}
def em_distance_approximate(data_1, data_2, encode_map, observables, simulator):

    x = CircuitStateFn(encode_map.bind_parameters(data_1))
    y = CircuitStateFn(encode_map.bind_parameters(data_2))

    em = 0

    for h in observables:

        measurable_x = StateFn(h, is_measurement=True).compose(x)
        measurable_y = StateFn(h, is_measurement=True).compose(y)

        expectation_x = PauliExpectation().convert(measurable_x)
        expectation_y = PauliExpectation().convert(measurable_y)

        sampler_x = CircuitSampler(simulator).convert(expectation_x)
        sampler_y = CircuitSampler(simulator).convert(expectation_y)

        current_expectation = abs(sampler_x.eval().real - sampler_y.eval().real)

        if current_expectation > em:
            em = current_expectation

    return em

def em_distance_exact(data_1, data_2, encode_map, observables):

    x = CircuitStateFn(encode_map.bind_parameters(data_1))
    y = CircuitStateFn(encode_map.bind_parameters(data_2))

    em = 0

    for h in observables:

        circuit_x = x.adjoint().compose(h).compose(x)
        circuit_y = y.adjoint().compose(h).compose(y)

        current_expectation = abs(circuit_x.eval().real - circuit_y.eval().real)

        if current_expectation > em:
            em = current_expectation

    return em


def em_dissimilarity_matrix(dataset, approximate = False):

    encode_map = ZZFeatureMap(feature_dimension=dataset.shape[1], reps=1, entanglement='linear', insert_barriers=True)
    n = encode_map.num_qubits
    observables = generate_pauli(n)
    mat = np.zeros((dataset.shape[0], dataset.shape[0]))

    if approximate:
        simulator = QasmSimulator()

        for i in range(dataset.shape[0]):
            for j in range(i):
                dis = em_distance_approximate(dataset[i], dataset[j], encode_map, observables, simulator)
                mat[i,j] = dis
                mat[j,i] = dis
    else:

        for i in range(dataset.shape[0]):
            for j in range(i):
                dis = em_distance_exact(dataset[i], dataset[j], encode_map, observables)
                mat[i,j] = dis
                mat[j,i] = dis

    return mat

def euclidean_matrix(dataset):
    mat = np.zeros((dataset.shape[0], dataset.shape[0]))

    for i in range(dataset.shape[0]):
        for j in range(i):
            dis = np.sqrt(np.sum((dataset[i] - dataset[j])**2))
            mat[i,j] = dis
            mat[j,i] = dis

    return mat


def manhattan_matrix(dataset):
    mat = np.zeros((dataset.shape[0], dataset.shape[0]))

    for i in range(dataset.shape[0]):
        for j in range(i):
            dis = np.sum(np.abs(dataset[i] - dataset[j]))
            mat[i,j] = dis
            mat[j,i] = dis

    return mat
\end{verbatim}

In~{[}~{]}:

\begin{verbatim}
iris = datasets.load_iris()['data'][15:35, :]
em_matrix = em_dissimilarity_matrix(iris, approximate=False)
\end{verbatim}

In~{[}~{]}:

\begin{verbatim}
%matplotlib inline

fig, axs = plt.subplots(1,3)
fig.set_size_inches(15,6)

axs[0].matshow(em_matrix, cmap='RdPu')
axs[0].set_title("EM Distance")
axs[1].matshow(manhattan_matrix(iris), cmap='RdPu')
axs[1].set_title("Manhattan Distance")
axs[2].matshow(euclidean_matrix(iris), cmap='RdPu')
axs[2].set_title("Euclidean Distance")

fig.show()
\end{verbatim}

\begin{verbatim}
/tmp/ipykernel_19799/3514324495.py:13: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
  fig.show()
\end{verbatim}

In~{[}~{]}:

\begin{verbatim}
blobs, classes = datasets.make_blobs(n_samples=50, random_state=10, n_features=2, centers=2)
blobs = np.array(blobs)

fig = plt.figure()
ax = fig.add_subplot(projection='3d')
ax.scatter(blobs[:,0], blobs[:,1], c=classes, cmap="Accent")
\end{verbatim}

Out{[}~{]}:

\begin{verbatim}
<mpl_toolkits.mplot3d.art3d.Path3DCollection at 0x7f4b4a939220>
\end{verbatim}

In~{[}~{]}:

\begin{verbatim}
em_matrix = em_dissimilarity_matrix(blobs)
\end{verbatim}

In~{[}~{]}:

\begin{verbatim}
%matplotlib inline

fig, axs = plt.subplots(1,3)
fig.set_size_inches(15,6)

axs[0].matshow(em_matrix, cmap='RdPu')
axs[0].set_title("EM Distance")
axs[1].matshow(manhattan_matrix(blobs), cmap='RdPu')
axs[1].set_title("Manhattan Distance")
axs[2].matshow(euclidean_matrix(blobs), cmap='RdPu')
axs[2].set_title("Euclidean Distance")

fig.show()
\end{verbatim}

\begin{verbatim}
/tmp/ipykernel_19799/362435202.py:13: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
  fig.show()
\end{verbatim}
